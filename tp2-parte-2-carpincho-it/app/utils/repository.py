from abc import ABC
from typing import Any, Generic, Sequence, TypeVar

from pydantic import BaseModel, Field, ValidationError
from sqlalchemy import Select
from sqlmodel import Session, SQLModel, select


class Filter(BaseModel):
    limit: int | None = Field(10)
    offset: int | None = Field(0)


Entity = TypeVar("Entity", bound=SQLModel)


class BaseRepository(ABC, Generic[Entity]):
    entity: type[Entity]

    def __init__(self, session: Session):
        """
        Base Repository class with database CRUD methods

        Usage:
        class YourSQLModelRepository(BaseRepository[YourSQLModel]):
            model = YourModel

        repo = YourSQLModelRepository(Session())
        instance = repo.get(1)
        """
        self.session = session

    def _build_filtered_statement(self, entity_filters: Filter | None = None) -> Select:
        if entity_filters is None:
            entity_filters = Filter()
        statement = select(self.entity)

        for key, value in entity_filters.model_dump(
            exclude=["limit", "offset"]
        ).items():
            statement = statement.where(getattr(self.entity, key) == value)

        return statement.limit(entity_filters.limit).offset(entity_filters.offset)

    def get_with_filter(
        self, entity_id: int, entity_filters: Filter | None = None
    ) -> Entity | None:
        statement = self._build_filtered_statement(entity_filters)

        statement = statement.where(self.entity.id == entity_id)

        result = self.session.exec(statement)

        return result.first()

    def get_all_with_filter(
        self, entity_filters: Filter | None = None
    ) -> Sequence[Entity]:
        statement = self._build_filtered_statement(entity_filters)

        result = self.session.exec(statement)

        return result.all()

    def get(self, entity_id: int) -> Entity | None:
        statement = select(self.entity).where(self.entity.id == entity_id)

        result = self.session.exec(statement)

        return result.first()

    def get_all(self) -> Sequence[Entity]:
        statement = self._build_filtered_statement()

        result = self.session.exec(statement)

        return result.all()

    def create(self, data: SQLModel) -> Entity:
        try:
            new_instance = self.entity(**data.model_dump())
        except ValidationError as e:
            raise ValueError(f"Invalid fields for model {self.entity.__name__}: {e}")

        self.session.add(new_instance)

        self.session.commit()
        self.session.refresh(new_instance)

        return new_instance

    def update(
        self,
        entity_id: int,
        data: SQLModel | dict[str, Any],
    ) -> Entity:
        instance = self.get(entity_id)

        if not instance:
            raise ValueError(f"{self.entity} instance with id {entity_id} not found")

        return self.update_instance(instance, data)

    def update_instance(
        self,
        instance: Entity,
        data: SQLModel | dict[str, Any] | None = None,
    ) -> Entity:
        """
        Updates an existing instance without querying it again.
        Relationships are handled manually due to `.model_dump` and `get_model_fields` in `sqlmodel_update` stripping them.
        See https://github.com/fastapi/sqlmodel/issues/224
        If a dictionary is passed in `data`, it must not be generated by `.model_dump` if it is desired to update relationships
        Alternatively, relationships can be modified on the instance and then a call to `update_instance` will add them.
        It isn't needed for `data` to be an object attached to a session.

        Although this method works, it raises several warnings. Specifically due to `data` being able to receive obejcts
        that are not attached to the session, created on the fly only for update. We mustn't add the `data` object to the
        session to prevent extra objects from being created.
        The warnings would be concerning if they weren't also raised in sqlmodel's CI,  oh well /ᐠﹷ ‸ ﹷ ᐟ\ﾉ.
        """
        relationships = instance.__sqlmodel_relationships__

        relationship_updates = {}
        update_data = {}

        if isinstance(data, SQLModel):
            update_data = data.model_dump(exclude_unset=True)
            for relationship in relationships:
                relationship_data = getattr(data, relationship, None)
                if relationship_data:
                    relationship_updates[relationship] = relationship_data
        elif isinstance(data, dict):
            update_data = data.copy()
            for key, value in update_data.items():
                if key in relationships:
                    relationship_updates[key] = value

        instance.sqlmodel_update(update_data)

        for relation, value in relationship_updates.items():
            setattr(instance, relation, value)

        self.session.add(instance)

        self.session.commit()
        self.session.refresh(instance)
        return instance

    def delete(self, entity_id: int) -> Entity:
        instance = self.get(entity_id)

        if instance:
            self.session.delete(instance)

            self.session.commit()
            return instance
        else:
            raise ValueError(f"Instance with id {entity_id} not found")
